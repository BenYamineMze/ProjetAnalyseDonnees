---
title: 'Projet: Reconnaissance faciale'
author: "Sébastien Vingadessin (36008909) et Ben yamine Mze Hamadi"
date: "21/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question 1. Lecture des données
`

### Liste des fichiers d'images de référence
```{r}
ref<-list.files(path = "./referenceFaceData",full.names=TRUE)
#ref
```

### Chargement de la librairie pixmap
```{r}
library(pixmap)
```

### Lecture des fichier d'images de référence
```{r}
imgRef=lapply(ref,read.pnm)
#lapply(imgRef,plot)
```

### Liste des matrices des images de référence
```{r}
imgRefMat=lapply(imgRef,function(x){x@grey[0:100,0:90]})
```

### Conversion des matrices d'images de référence en vecteurs
```{r}
imgRefVector=lapply(imgRefMat,function(x){as.vector(t(x))})
#length(imgRefVector[[1]])
```
### Construction de la matrice dont les lignes sont les vecteurs de imgRefVector
```{r}
imgRefMatPCA=t(sapply(imgRefVector,rbind))
```
### Noms des lignes de la matrice imgRefMatPCA
```{r}
rownames(imgRefMatPCA)=lapply(1:nrow(imgRefMatPCA),function(x){v=paste("r",x)})
imgRefMatPCA[,1:5]
```
### Liste des fichiers d'images test
```{r}
test<-list.files(path = "./testFaceData",full.names=TRUE)
test
```
### Lecture des fichier d'images test
```{r}
imgTest=lapply(test,read.pnm)
#lapply(imgTest,plot)
```
### Liste des matrices des images test
```{r}
imgTestMat=lapply(imgTest,function(x){x@grey[0:100,0:90]})
```
### Conversion des matrices d'images test en vecteurs
```{r}
imgTestVector=lapply(imgTestMat,function(x){as.vector(t(x))})
```
# Construction de la matrice dont les lignes sont les vecteurs de imgTestVector
```{r}
imgTestMatPCA=t(sapply(imgTestVector,rbind))
```
### Noms des lignes de la matrice imgTestMatPCA
```{r}
rownames(imgTestMatPCA)=lapply(1:nrow(imgTestMatPCA),function(x){v=paste("t",x)})
```
### Construction de la matrice de données contenant les vecteurs visages de référence et vecteurs visages test
```{r}
donnees<- rbind(imgRefMatPCA, imgTestMatPCA)
dim(donnees)
```


## Question 2. ACP

# Chargement de la librairie FactoMineR
```{r}
library(FactoMineR)
```
# Construction de l'ACP par la matrice des données des vecteurs des visages de référence et des visages tests
```{r}
acp<-PCA(donnees, scale.unit = FALSE, ncp = Inf)
```
  
  
## Question 2.a (Ben yamine Mze Hamadi)

```{r}
#Valeurs propres données par l'ACP
Vp<-acp$eig[,1]
```

# kaiser est une fonction qui calcule le nombre d'axes factoriels
# Elle prend en paramètre les valeurs propres des données reçues par l'ACP
# et renvoie le nombre d'axes factoriels
```{r}
kaiser<-function(valP){
  Imoy<-sum(valP)/length(valP)
  res<-length(valP[valP>Imoy])
  return(res)
}

k<-kaiser(Vp)
k
```

## Question 2.b (Sébastien Vingadessin)

# La fonction pInexp détermine le pourcentage d'inertie expliqué
# Elle prend en paramètre les valeurs propres des données reçues par l'ACP
# Et renvoie le pourcentage d'inertie expliqué sous l'espace factoriel retenu par l'application de la fonction Kaiser vue précédemment.

```{r}
pInexp<-function(valP){
  In<-sum(valP)
  return(sum(valP[1:k])*100/In)
}

pInexp(Vp)
```


## Question 2.c (Ben yamine Mze Hamadi)

# La fonction planFact détermine le plan factoriel sur lequel le visage test est le mieux représenté, ainsi que le pourcentage d'inertie.
# Elle prend en paramètre les valeurs de l'ACP.
# Elle renvoie une matrice présentant les dimensions des plans factoriels retenus ainsi que les pourcentages d'inertie expliquée par le plan en question.

```{r}
planFact<-function(tab){
  res<-c()
  ij<-c(0,0)
  
  for(n in 1:5){
    max<-0
    for(i in 1:k){
      for(j in 1:k){
        if(j>i){
          if(tab[10+n,i]+tab[10+n,j] > max){
            max = tab[10+n,i]+tab[10+n,j]
            ij=c(i,j)
          }
        }
      }
    }
    res = c(res,ij,(Vp[ij[1]]+Vp[ij[2]])*100/sum(Vp))
  }
  
  M<-matrix(res,ncol = 5)
  rownames(M)=c("dim1","dim2","%inertie")
  colnames(M)=c("image 1","image 2","image 3","image 4","image 5")
  return(M)
}


```

# Application de la fontion PlanF définie précédemment 
```{r}
cos<-acp$ind$cos2
planF<-planFact(cos)
planF
```


## Question 2.d (Sébastien Vingadessin) 
 

```{r}
coor<-acp$ind$coord

for(p in 1:5){
  x<-coor[,planF[1,p]]
  x=c(x[1:10],coor[10+p,planF[1,p]])
  y<-coor[,planF[2,p]]
  y=c(y[1:10],coor[10+p,planF[2,p]])
  
  plot(x,y,type = "p")
}

```



## Question 2.e (Sébastien Vingadessin)


```{r}
distTest<-function(cord){
  res<-matrix(c(1:5,rep(0,5)),ncol = 2)
  colnames(res) = c("test","ref")
  
  #image test t
  
  for(t in 1:5){
    num<-0
    dmin<-1000000
    m<-matrix(c(1:(2*k)),nrow=2)
    m[1,]=cord[10+t,1:k]
    
    for(i in 1:10){
      m[2,]=cord[i,1:k]
      if(dist(m,method = "euclidean") < dmin) {
        dmin = dist(m,method = "euclidean")
        num = i
      }
    }
    
    res[t,2] = num
  }
  
  return(res)
}

distTest(coor)
```


## Question 2.f (Ben yamine Mze Hamadi)

```{r}
identif<-function(cord){
  tab<-distTest(cord)
  
  for(i in 1:5){
    lapply(imgTest[i],plot)
    lapply(imgRef[tab[i,2]],plot)
  }
}
```



```{r}
identif(coor)
```



## Question 3. (Ben yamine Mze Hamadi)


```{r}
#Nuage de point projeté
nuage<-coor[,1:4]

#Matrice des dissimilarités du nuage, selon la distance euclidienne
d<-dist(nuage, method = "euclidean")
d
```

```{r}
#CAH par le lien simple
h<-hclust(d, method = "single", members = NULL)
plot(h)
```



```{r}
listClass<-function(cah){
  mg<-cah$merge
  lab<-cah$labels
  res<-list()
  
  comp1<-NULL
  comp2<-NULL
  
  for(i in 1:14){
    
    if(mg[i,1]<0) comp1 = lab[-mg[i,1]]
    else comp1 = res[[mg[i,1]]]
    
    if(mg[i,2]<0) comp2 = lab[-mg[i,2]]
    else comp2 = res[[mg[i,2]]]
    
    res[[i]] = c(comp1,comp2)
  }
  
  return(res)
}
```


```{r}
Lclass<-listClass(h)

Lclass
```



## Question 4. (Sébastien Vingadessin) 

```{r}
pluspetiteClasse<-function(listC){
  res<-list("0","0","0","0","0")
  lab<-h$labels
  class<-NULL
  for(t in 1:5){
    
    for(i in 1:14){
      class=listC[[i]]
      
      for(j in 1:length(class)){
        if(class[j] == lab[t+10]){
          res[[t]] = class
          break
        }
      }
      if(length(res[[t]]) > 1) break
    }
    
  }
  return(res)
}

testClass<-pluspetiteClasse(Lclass)
testClass
```



## Question 5 (Ben yamine Mze Hamadi et Sébastien Vingadessin)

```{r}
visageClasse<-function(tClass){
  allImg<-c(imgRef,imgTest)
  class<-NULL
  
  for(i in 1:5){
    class=tClass[[i]]
    
    for(j in 1:length(class)){
      im<-class[j]
      for(p in 1:15){
        if(im == h$labels[p]){
          lapply(allImg[p],plot)
          break
        }
      }
    }
    
  }
}

visageClasse(testClass)
```









